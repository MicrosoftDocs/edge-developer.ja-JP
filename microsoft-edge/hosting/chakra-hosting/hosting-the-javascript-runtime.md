---
description: 標準ベースの Chakra JavaScript エンジンを使って、Windows アプリケーションにスクリプト機能を追加します。
title: JavaScript ランタイムのホスティング
ms.date: 06/18/2020
ms.prod: microsoft-edge
ms.topic: article
ms.assetid: 30ec744e-57cc-4ef5-8fe1-d2c27b946548
caps.latest.revision: 14
author: MSEdgeTeam
ms.author: msedgedevrel
ms.openlocfilehash: 043f7ecd174515ce407d2fc0c2bbe796fa2750a5
ms.sourcegitcommit: 037a2d62333691104c9accb4862968f80a3465a2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/18/2020
ms.locfileid: "10752249"
---
# <span data-ttu-id="3cffe-103">JavaScript ランタイムのホスト</span><span class="sxs-lookup"><span data-stu-id="3cffe-103">Hosting the JavaScript runtime</span></span>  

[!INCLUDE [deprecation-note](../includes/deprecation-note.md)]  

<span data-ttu-id="3cffe-104">JavaScript Runtime (JsRT) Api は、Windows オペレーティングシステムで実行されているデスクトップ、Windows ストア、サーバー側アプリケーションのための手段を提供します。これは、Microsoft Edge と Internet Explorer でも利用される標準ベースの Chakra JavaScript エンジンを使って、アプリケーションにスクリプト機能を追加します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-104">The JavaScript Runtime (JsRT) APIs provide a way for desktop, Windows Store, and server-side applications running on the Windows operating system to add scripting capabilities to the application by using the standards-based Chakra JavaScript engine that is also utilized by Microsoft Edge and Internet Explorer.</span></span> <span data-ttu-id="3cffe-105">これらの Api は、Windows 10 と、Internet Explorer バージョン11.0 がコンピューターにインストールされているすべてのバージョンの Windows オペレーティングシステムで使用できます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-105">These APIs are available on Windows 10 and any version of the Windows operating system that has Internet Explorer version 11.0 installed on the machine.</span></span> <span data-ttu-id="3cffe-106">詳しくは、「[リファレンス (JavaScript ランタイム)](../chakra-hosting/reference-javascript-runtime.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="3cffe-106">For more info, see [Reference (JavaScript Runtime)](../chakra-hosting/reference-javascript-runtime.md).</span></span> <span data-ttu-id="3cffe-107">Windows ストアアプリでの JsRT の使用について詳しくは、「 [JsRT とユニバーサル Windows プラットフォーム](#Windows)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="3cffe-107">For info on using the JsRT in Windows Store apps, see [JsRT and the Universal Windows Platform](#Windows).</span></span>  

> [!NOTE]
> <span data-ttu-id="3cffe-108">このドキュメントでは、JavaScript の言語についてよく理解していることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="3cffe-108">This documentation assumes a general working familiarity with the JavaScript language.</span></span>  

## <span data-ttu-id="3cffe-109">概念</span><span class="sxs-lookup"><span data-stu-id="3cffe-109">Concepts</span></span>  

<span data-ttu-id="3cffe-110">JsRT Api を使って JavaScript エンジンをホストする方法については、次の2つの主要な概念 (ランタイムと実行コンテキスト) に依存します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-110">Understanding how to host the JavaScript engine using the JsRT APIs depends on two key concepts: runtimes and execution contexts.</span></span>  

<span data-ttu-id="3cffe-111">*ランタイム*は、完全な JavaScript 実行環境を表します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-111">A *runtime* represents a complete JavaScript execution environment.</span></span> <span data-ttu-id="3cffe-112">作成される各ランタイムには、独自の分離されたガベージコレクションのヒープと、既定で、専用のジャストインタイム (JIT) コンパイラスレッドとガベージコレクター (GC) スレッドがあります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-112">Each runtime that is created has its own isolated garbage collected heap and, by default, its own just-in-time (JIT) compiler thread and garbage collector (GC) thread.</span></span> <span data-ttu-id="3cffe-113">*実行コンテキスト*は、他のすべての実行コンテキストとは異なる独自の javascript グローバルオブジェクトを持つ javascript 環境を表します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-113">An *execution context* represents a JavaScript environment that has its own JavaScript global object distinct from all other execution contexts.</span></span> <span data-ttu-id="3cffe-114">1つのランタイムには複数の実行コンテキストが含まれている可能性があります。その場合、すべての実行コンテキストは、ランタイムに関連付けられている JIT コンパイラと GC スレッドを共有します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-114">One runtime may contain multiple execution contexts, and in such cases, all the execution contexts share the JIT compiler and GC thread associated with the runtime.</span></span>  

<span data-ttu-id="3cffe-115">ランタイムは、1つの実行スレッドを表します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-115">Runtimes represent a single thread of execution.</span></span> <span data-ttu-id="3cffe-116">特定のスレッドでアクティブにできるランタイムは一度に1つだけであり、ランタイムは一度に1つのスレッドでのみアクティブにすることができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-116">Only one runtime can be active on a particular thread at a time, and a runtime can only be active on one thread at a time.</span></span> <span data-ttu-id="3cffe-117">ランタイムはレンタルスレッドであるため、現在スレッドでアクティブになっていないランタイム (つまり、JavaScript コードが実行されていないか、ホストからのすべての呼び出しに応答しない) は、アクティブなランタイムをまだ持っていないすべてのスレッドで使うことができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-117">Runtimes are rental threaded, so a runtime that is not currently active on a thread (i.e. isn't running any JavaScript code or responding to any calls from the host) can be used on any thread that doesn't already have an active runtime on it.</span></span>  

<span data-ttu-id="3cffe-118">実行コンテキストは、特定のランタイムに関連付けられ、そのランタイム内でコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-118">Execution contexts are tied to a particular runtime and execute code within that runtime.</span></span> <span data-ttu-id="3cffe-119">ランタイムとは異なり、一度に複数の実行コンテキストをスレッドでアクティブにすることができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-119">Unlike runtimes, multiple execution contexts can be active on a thread at the same time.</span></span> <span data-ttu-id="3cffe-120">そのため、ホストは実行コンテキストに呼び出しを行うことができます。これにより、実行コンテキストはホストにコールバックすることができ、ホストは別の実行コンテキストに呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-120">So a host can make a call into an execution context, that execution context can call back to the host, and the host can make a call into a different execution context.</span></span>  

![複数の実行コンテキスト](../chakra-hosting/media/js-chakra-hosting.png "JS_Chakra_Hosting")  

<span data-ttu-id="3cffe-122">実際には、ホストが分離された環境でコードを実行する必要がない限り、1つの実行コンテキストを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-122">In practice, unless a host needs to run code in separated environments, a single execution context can be used.</span></span> <span data-ttu-id="3cffe-123">同様に、ホストで複数のコードを同時に実行する必要がない場合は、1つのランタイムで十分です。</span><span class="sxs-lookup"><span data-stu-id="3cffe-123">Similarly, unless a host needs to run multiple pieces of code concurrently, a single runtime is sufficient.</span></span>  

## <span data-ttu-id="3cffe-124">メモリ管理</span><span class="sxs-lookup"><span data-stu-id="3cffe-124">Memory management</span></span>  

<span data-ttu-id="3cffe-125">JavaScript はガベージコレクションされた言語であるため、別の言語の JsRT Api を使用する際に考慮する必要があるいくつかの考慮事項があります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-125">JavaScript is a garbage collected language, and thus there are several considerations that must be kept in mind when working with the JsRT APIs from another language.</span></span>  

<span data-ttu-id="3cffe-126">主な考慮事項は、JavaScript のガベージコレクターは、実行時のヒープとスタックという2つの場所の値への参照のみを見ることができることです。</span><span class="sxs-lookup"><span data-stu-id="3cffe-126">The main consideration is that the JavaScript garbage collector can only see references to values in two places: its runtime's heap, and the stack.</span></span> <span data-ttu-id="3cffe-127">そのため、別の JavaScript 値またはスタックのローカル変数に格納されている JavaScript 値への参照は、常にガベージコレクターによって表示されます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-127">Thus, a reference to a JavaScript value that is stored inside of another JavaScript value or in a local variable on the stack will always be seen by the garbage collector.</span></span> <span data-ttu-id="3cffe-128">ただし、ホストやシステムによって管理されるヒープなど、他の場所に保存されている参照は、ガベージコレクターによっては表示されず、ホストでまだ使用されている値の収集が早すぎる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-128">But references stored in other locations, such as heaps managed by the host or the system, will not be seen by the garbage collector and may result in premature collection of values that are still in use by the host.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="3cffe-129">一部の言語コンパイラ (Visual Studio C++ コンパイラなど) では、可能な限りローカル変数を最適化します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-129">Some language compilers (such as the Visual Studio C++ compiler) will optimize away local variables where possible.</span></span> <span data-ttu-id="3cffe-130">JavaScript の値を参照するローカル変数は、それらの値を保持する必要がある場合は、スタック上にあることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-130">Care must be taken to ensure that local variables that reference JavaScript values are on the stack if they are expected to keep those values alive.</span></span>  

<span data-ttu-id="3cffe-131">JavaScript 値への参照がガベージコレクターに表示されない場所に格納される場合は、ホストは JsRT Api を使って参照を手動で追加および削除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-131">If a reference to a JavaScript value will be stored in a location not visible to the garbage collector, the host must manually add and remove references using the JsRT APIs.</span></span>  

## <span data-ttu-id="3cffe-132">例外処理</span><span class="sxs-lookup"><span data-stu-id="3cffe-132">Exception handling</span></span>  

<span data-ttu-id="3cffe-133">スクリプトの実行中に JavaScript 例外が発生すると、それを含むランタイムが例外の状態になります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-133">When a JavaScript exception occurs during script execution, the containing runtime is put into an exception state.</span></span> <span data-ttu-id="3cffe-134">例外状態では、コードが実行されることはありません。また、ホストが `JsErrorInExceptionState` api を使って例外を取得してクリアするまで、すべての api 呼び出しがエラーコードで失敗し `JsGetAndClearException` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-134">While in an exception state, no code can run and all API calls will fail with the error code `JsErrorInExceptionState` until the host retrieves and clears the exception using the `JsGetAndClearException` API.</span></span> <span data-ttu-id="3cffe-135">ホストが、例外状態からランタイムをクリアせずに JavaScript コールバックから返された場合、コントロールが JavaScript エンジンに戻されるとすぐに、JavaScript 例外が再スローされます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-135">If the host returns from a JavaScript callback without clearing the runtime from an exception state, then the JavaScript exception will be re-thrown as soon as control passes back to the JavaScript engine.</span></span> <span data-ttu-id="3cffe-136">これにより、ホストコールバックは、ランタイムを例外の状態に設定してから、ホストのコールバックから返すことで、JavaScript 例外を "スロー" することもできます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-136">This also enables host callbacks to "throw" a JavaScript exception by setting the runtime into an exception state and then returning from a host callback.</span></span>  

<span data-ttu-id="3cffe-137">ホストは、独自の内部例外をホストコールバック間で伝達することはできません。すべてのコールバックメソッドは、コントロールをランタイムに返す前にすべてのホスト例外をキャッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-137">A host is not allowed to let its own internal exceptions to propagate across a host callback—any callback methods must catch all host exceptions before returning control to the runtime.</span></span>  

## <span data-ttu-id="3cffe-138">ランタイムリソースの使用状況</span><span class="sxs-lookup"><span data-stu-id="3cffe-138">Runtime resource usage</span></span>  

<span data-ttu-id="3cffe-139">JsRT Api は、ランタイムがリソースを使う方法を監視および変更するためのさまざまな方法を公開します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-139">The JsRT APIs expose a number of way to monitor and modify the way runtimes use resources.</span></span> <span data-ttu-id="3cffe-140">通常は、次のカテゴリに分類されます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-140">They generally break down into the following categories:</span></span>  

*   <span data-ttu-id="3cffe-141">**スレッドの使用**。</span><span class="sxs-lookup"><span data-stu-id="3cffe-141">**Thread Usage**.</span></span> <span data-ttu-id="3cffe-142">既定では、各ランタイムは専用の JIT コンパイラスレッドと、そのランタイムを処理する専用の GC スレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-142">By default, each runtime will create a dedicated JIT compiler thread and a dedicated GC thread that service that runtime.</span></span> <span data-ttu-id="3cffe-143">このフラグを使ってランタイムを作成した場合、JIT と GC の動作は、それぞれの `JsRuntimeAttributeDisableBackgroundWork` 1 つについて別個のバックグラウンドスレッドではなく、ランタイムスレッド自体で実行されます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-143">If a runtime is created with the `JsRuntimeAttributeDisableBackgroundWork` flag, then the JIT and GC work will be performed on the runtime thread itself instead of separate background threads for each one of them.</span></span> <span data-ttu-id="3cffe-144">また、ホストは、呼び出しへのスレッドサービスコールバックを提供することもできます。これによって、 `JsCreateRuntime` ホストは JIT と GC の動作を適切な方法でスケジュールすることができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-144">A host can also supply a thread service callback to the `JsCreateRuntime` call, which will allow the host to schedule JIT and GC work in any way it sees fit.</span></span>
*   <span data-ttu-id="3cffe-145">**メモリ使用量**。</span><span class="sxs-lookup"><span data-stu-id="3cffe-145">**Memory Usage**.</span></span> <span data-ttu-id="3cffe-146">ランタイムのメモリ使用量を監視し、変更するには、いくつかの方法があります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-146">There are several ways to monitor and modify the memory usage of a runtime.</span></span> <span data-ttu-id="3cffe-147">ランタイムが長時間実行されている場合は、ホストで `JsRuntimeAttributeEnableIdleProcessing` ランタイムを作成するときにフラグを指定し、 `JsIdle` ホストがアイドル状態のときに呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-147">If the runtime will be running for a long time, the host can specify the `JsRuntimeAttributeEnableIdleProcessing` flag when creating the runtime and then call `JsIdle` when the host is in an idle state.</span></span> <span data-ttu-id="3cffe-148">これにより、エンジンは、一部のメモリクリーンアップと簿記の処理をアイドル時間まで延期することができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-148">This allows the engine to defer some memory cleanup and bookkeeping work until idle time.</span></span>  
    
    <span data-ttu-id="3cffe-149">ホストは、を呼び出してガベージコレクションを監視でき `JsSetRuntimeBeforeCollectCallback` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-149">The host can monitor garbage collections by calling `JsSetRuntimeBeforeCollectCallback`.</span></span> <span data-ttu-id="3cffe-150">また、を呼び出してヒープによって行われた割り当てを監視することもでき `JsSetRuntimeMemoryAllocationCallback` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-150">It can also monitor allocations made by the heap by calling `JsSetRuntimeMemoryAllocationCallback`.</span></span> <span data-ttu-id="3cffe-151">この API は、すべての JavaScript の割り当てについては呼び出されません。つまり、ランタイムのヒープで割り当てる必要のある領域がさらに必要な場合だけです。</span><span class="sxs-lookup"><span data-stu-id="3cffe-151">Note that this API does not call back on every JavaScript allocation, just when the runtime's heap needs more space from which to allocate.</span></span> <span data-ttu-id="3cffe-152">メモリ割り当てのコールバックでは、要求を拒否することができます。これにより、ガベージコレクションがトリガーされ、メモリが利用できない場合、ランタイムにメモリ不足のエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-152">The memory allocation callback is allowed to deny the request, which will trigger a garbage collection and, if no memory is available, an out of memory error in the runtime.</span></span>  
    
    <span data-ttu-id="3cffe-153">ホストは、ランタイムが `JsSetRuntimeMemoryLimit` 使うことができるメモリの量に対する制限を設定するために呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-153">The host can also call `JsSetRuntimeMemoryLimit` to set a limit for how much memory a runtime can use.</span></span> <span data-ttu-id="3cffe-154">ランタイムが制限をヒットすると、ガベージコレクションがトリガーされ、メモリが利用できない場合、ランタイムによってメモリ不足のエラーがスローされます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-154">When a runtime hits a limit, it will trigger a garbage collection and, if no memory is available, an out of memory error will be thrown by the runtime.</span></span>  
    
*   <span data-ttu-id="3cffe-155">**スクリプトの中断と評価**。</span><span class="sxs-lookup"><span data-stu-id="3cffe-155">**Script Interruption and Evaluation**.</span></span> <span data-ttu-id="3cffe-156">ホストは、 `JsDisableRuntimeExecution` ランタイム内で実行を終了するために呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-156">The host can call `JsDisableRuntimeExecution` to terminate execution within a runtime.</span></span> <span data-ttu-id="3cffe-157">この通話は、どのスレッドからでもいつでも行うことができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-157">This call can be made at any time and from any thread.</span></span> <span data-ttu-id="3cffe-158">スクリプトの終了は、コードに挿入されたガードポイントへの到達に依存するため、スクリプトは正確な瞬間に終了しないことがありますが、その後すぐに実行されます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-158">Because script termination depends on reaching guard points inserted into the code, a script may not terminate at the exact moment, but will do so very shortly afterwards.</span></span> <span data-ttu-id="3cffe-159">既定では、終了ガードポイントは、生成されたコード conservatively 内に配置され、無限ループなど、すべての状況をカバーすることはできません。</span><span class="sxs-lookup"><span data-stu-id="3cffe-159">By default, termination guard points are placed in the generated code conservatively and may not cover every situation, such as an infinite loop.</span></span> <span data-ttu-id="3cffe-160">このフラグを使ってランタイムを作成 `JsRuntimeAttributeAllowScriptInterrupt` すると、実行時に無限ループの追加チェックが挿入され、多くの場合、パフォーマンスがわずかに低下します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-160">Creating the runtime with the `JsRuntimeAttributeAllowScriptInterrupt` flag causes the runtime to insert additional checks for infinite loops, often at the cost of a small performance overhead.</span></span>  
    
    <span data-ttu-id="3cffe-161">ホストで JIT コンパイラによるネイティブコードの生成を許可しない場合は、フラグを指定でき `JsRuntimeAttributeDisableNativeCodeGeneration` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-161">If a host wishes to disallow generation of native code by the JIT compiler, it can specify the `JsRuntimeAttributeDisableNativeCodeGeneration` flag.</span></span> <span data-ttu-id="3cffe-162">また、ホストでは、フラグを指定することによって、動的に実行されるスクリプト自体からスクリプトを拒否することもでき `JsRuntimeAttributeDisableEval` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-162">A host can also disallow scripts from dynamically running scripts itself by specifying the `JsRuntimeAttributeDisableEval` flag.</span></span>  
    
## <span data-ttu-id="3cffe-163">デバッグとプロファイリング</span><span class="sxs-lookup"><span data-stu-id="3cffe-163">Debugging and profiling</span></span>  

<span data-ttu-id="3cffe-164">JsRT Api では、アクティブなスクリプトテクノロジによるデバッグとプロファイリングがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="3cffe-164">JsRT APIs supports debugging and profiling via the Active Scripting technology.</span></span>  

<span data-ttu-id="3cffe-165">Windows 10 以降では、Chakra JavaScript エンジンは従来の Internet Explorer (MSHTML) エンジンと新しい Microsoft Edge (EdgeHTML) エンジンをサポートしており、JsRT のいずれかをターゲットにできます (詳しくは、「 [Microsoft edge とレガシエンジン](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md)のターゲット設定」をご覧ください)。</span><span class="sxs-lookup"><span data-stu-id="3cffe-165">Starting in Windows 10, the Chakra JavaScript Engine supports the legacy Internet Explorer (MSHTML) engine and new Microsoft Edge (EdgeHTML) engine, and you can target either in JsRT (see [Targeting Microsoft Edge vs. Legacy Engines](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md) for details).</span></span> <span data-ttu-id="3cffe-166">Visual Studio でのスクリプトのデバッグは、従来のエンジンと Microsoft Edge のエンジンでは動作が異なります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-166">Debugging a script in Visual Studio works differently between the legacy engine and Microsoft Edge engine.</span></span> <span data-ttu-id="3cffe-167">従来のエンジンでは、ホストは[Iprocessdebugmanager インターフェイス](/scripting/winscript/reference/iprocessdebugmanager-interface)インスタンスから取得できる[IDebugApplication Interface](/scripting/winscript/reference/idebugapplication-interface)ポインターを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-167">With the legacy engine, the host needs to provide an [IDebugApplication Interface](/scripting/winscript/reference/idebugapplication-interface) pointer, which can be obtained from an [IProcessDebugManager Interface](/scripting/winscript/reference/iprocessdebugmanager-interface) instance.</span></span> <span data-ttu-id="3cffe-168">Microsoft Edge エンジンで `IDebugApplication` は廃止され、Chakra エンジンは、ユーザーからの実装を必要とせずに、Visual Studio デバッガーを通じてネイティブおよびスクリプトのデバッグ機能を有効にし `IDebugApplication` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-168">With the Microsoft Edge engine, `IDebugApplication` is deprecated, and the Chakra engine enables native and script debugging capabilities through the Visual Studio debugger without requiring an implementation of `IDebugApplication` from the user.</span></span>  

<span data-ttu-id="3cffe-169">実行コンテキストのスクリプトをデバッグ可能にするには、Chakra engine では、効率の低いコード実行メソッドを使用するように切り替える必要があります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-169">To make scripts in an execution context debuggable, the Chakra engine has to switch to using less efficient code execution methods.</span></span> <span data-ttu-id="3cffe-170">したがって、通常、デバッグ可能なコードは、デバッグできないコードよりも動作が遅くなります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-170">As such, debuggable code typically runs slower than non-debuggable code.</span></span> <span data-ttu-id="3cffe-171">この結果、従来のエンジンでは、ホストは、最初にポインターを前に移動することによって、最初の実行コンテキストでデバッグを開始するか `IDebugApplication` 、デバッグが必要になってから呼び出すかを選択でき `JsCreateContext` `JsStartDebugging` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-171">As a result, with the legacy engine, a host can choose to either start debugging in an execution context from the beginning by providing the `IDebugApplication` pointer up front through `JsCreateContext`, or it can wait until debugging is needed and then call `JsStartDebugging`.</span></span> <span data-ttu-id="3cffe-172">Microsoft Edge エンジンでは、パラメーターが不要になった `JsCreateContext` `IDebugApplication` ため、その結果として、が呼び出された後にのみ、スクリプトはデバッグ可能になり `JsStartDebugging` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-172">With the Microsoft Edge engine, `JsCreateContext` no longer takes an `IDebugApplication` parameter, and as a result the script is debuggable only after `JsStartDebugging` is called.</span></span> <span data-ttu-id="3cffe-173">Visual Studio を使ってデバッグする場合は、"Script" デバッガーオプションを有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3cffe-173">When debugging using Visual Studio, the "Script" debugger option must be enabled.</span></span>  

<span data-ttu-id="3cffe-174">実行コンテキストの JavaScript コードは、次の2つの方法のいずれかでプロファイリングできます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-174">The JavaScript code in an execution context can be profiled in one of two ways.</span></span> <span data-ttu-id="3cffe-175">Visual Studio Profiler (vsperf.exe) コマンドラインは、Windows 8.1 以降のバージョンで、/js スイッチを使用して、アプリケーションで実行される JavaScript コードのターゲットとなるレポートを生成することができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-175">The command line Visual Studio Profiler (vsperf.exe) can be used in Windows 8.1 and later versions with the /js switch to produce a report that targets the JavaScript code run in the application.</span></span> <span data-ttu-id="3cffe-176">または、ホストが直接呼び出すことができ `JsStartProfiling` `JsStopProfiling` ます。また、コールバックを提供してプロファイリングを行うこともできます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-176">Or the host can directly call `JsStartProfiling` and `JsStopProfiling` and provide a callback to do profiling itself.</span></span> <span data-ttu-id="3cffe-177">ホストは、呼び出しによってガベージコレクションされたヒープの状態を調査することもでき `JsEnumerateHeap` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-177">The host can also examine the state of the garbage collected heap by calling `JsEnumerateHeap`.</span></span> <span data-ttu-id="3cffe-178">JsRT でのプロファイリングは、従来と Microsoft Edge エンジンと同じ方法で動作します。</span><span class="sxs-lookup"><span data-stu-id="3cffe-178">Profiling in JsRT works in the same manner between the legacy and the Microsoft Edge engine.</span></span> <span data-ttu-id="3cffe-179">ただし、ユニバーサル Windows アプリでは、JsRT のプロファイリング api (、、、など `JsStartProfiling` `JsStopProfiling` `JsEnumerateHeap` `JsIsEnumeratingHeap` ) は使用できません。</span><span class="sxs-lookup"><span data-stu-id="3cffe-179">However, JsRT profiling APIs (`JsStartProfiling`, `JsStopProfiling`, `JsEnumerateHeap`, and `JsIsEnumeratingHeap`) are not available for Universal Windows Apps.</span></span>  

<a name="Windows"></a>   

## <span data-ttu-id="3cffe-180">JsRT とユニバーサル Windows プラットフォーム</span><span class="sxs-lookup"><span data-stu-id="3cffe-180">JsRT and the Universal Windows Platform</span></span>  

<span data-ttu-id="3cffe-181">JsRT Api を使って、ユニバーサル Windows アプリにスクリプト機能を追加することができます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-181">You can use JsRT APIs to add scripting capabilities to a Universal Windows app.</span></span> <span data-ttu-id="3cffe-182">JsRT Api を使うユニバーサル Windows アプリでは、Microsoft Edge JSRT Api をターゲットとして指定する必要があります。これは、Edge Chakra engine をターゲットとしています。</span><span class="sxs-lookup"><span data-stu-id="3cffe-182">A Universal Windows app that uses the JsRT APIs will need to target the Microsoft Edge JSRT APIs, which in turn target the Edge Chakra engine.</span></span> <span data-ttu-id="3cffe-183">詳細については、「 [Microsoft Edge とレガシエンジンのターゲット](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md)設定」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3cffe-183">For more information, see [Targeting Microsoft Edge vs. Legacy Engines](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md).</span></span> <span data-ttu-id="3cffe-184">完全な JsRT API は、ユニバーサル Windows アプリで利用できます。ただし、プロファイリングとヒープ列挙のサポート (、、、 `JsStartProfiling` `JsStopProfiling` はサポートされ `JsEnumerateHeap` `JsIsEnumeratingHeap` ていません)。</span><span class="sxs-lookup"><span data-stu-id="3cffe-184">The complete JsRT API is available for Universal Windows apps, except for profiling and heap enumeration support (`JsStartProfiling`, `JsStopProfiling`, `JsEnumerateHeap`, and `JsIsEnumeratingHeap` are not supported).</span></span>  

<span data-ttu-id="3cffe-185">また、Microsoft Edge JsRT API を使用して API 名前空間を公開した後、JsRT によって、スクリプトは[ユニバーサル Windows プラットフォーム (UWP) api](https://msdn.microsoft.com/library/windows/apps/br211377.aspx)にネイティブにアクセスでき `JsProjectWinRTNamespace` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-185">JsRT also allows scripts to natively access any [Universal Windows Platform (UWP) APIs](https://msdn.microsoft.com/library/windows/apps/br211377.aspx) after exposing the API namespace through Microsoft Edge JsRT API `JsProjectWinRTNamespace`.</span></span> <span data-ttu-id="3cffe-186">ユニバーサル Windows アプリケーションでは、必要な名前空間を設定する必要はありませんが、従来の (Win32) Windows アプリケーションでは、COM で初期化されたデリゲートメカニズムを有効にして、イベントと非同期 Api を有効にする必要があり `JsSetProjectionEnqueueCallback` ます。</span><span class="sxs-lookup"><span data-stu-id="3cffe-186">While Universal Windows Applications require no setup in addition to projecting necessary namespaces, in a Classic (Win32) Windows Application, a COM-initialized delegated pumping mechanism needs to be enabled through `JsSetProjectionEnqueueCallback` to enable events and asynchronous APIs.</span></span> <span data-ttu-id="3cffe-187">次の Win32 サンプルでは、非同期 UWP Api を使って、Uri からコンテンツを取得するための http クライアントを作成しています。</span><span class="sxs-lookup"><span data-stu-id="3cffe-187">The following Win32 sample utilizes asynchronous UWP APIs to create an http client to get content from a Uri:</span></span>  

```cpp
typedef struct _jsCall {
    JsProjectionCallback jsCallback;
    JsProjectionCallbackContext jsContext;
    HANDLE event;
} jsCall;

// Set up delegated pumping mechanism; not necessary in UWP applications.
jsCall outstandingCall = {};
CoInitializeEx(nullptr, COINIT_MULTITHREADED);
JsSetProjectionEnqueueCallback([](JsProjectionCallback jsCallback,
JsProjectionCallbackContext jsContext, void *callbackState) {
    jsCall* call = (jsCall*)callbackState;
    call->jsCallback = jsCallback;
    call->jsContext = jsContext;
    SetEvent(call->event);
    },
&outstandingCall);
HANDLE event = CreateEventEx(NULL, NULL, CREATE_EVENT_MANUAL_RESET, EVENT_ALL_ACCESS);
outstandingCall.event = event;

// Project necessary namespaces.
JsProjectWinRTNamespace(L"Windows.Foundation");
JsProjectWinRTNamespace(L"Windows.Web");

// Get content from an Uri.
JsRunScript(L"var uri = new Windows.Foundation.Uri(\"http://somedatasource.com\"); " \
    L"var httpClient = new Windows.Web.Http.HttpClient();" \
    L"httpClient.getStringAsync(uri).done(function (content) { " \
    L"    // do something with the string content " \
    L"}, onError); " \
    L"function onError(reason) { " \
    L"    // error handling " \
    L"}",
    currentSourceContext, L"", &result);

// Wait for async call to come in and then execute; not necessary in UWP applications.
WaitForSingleObjectEx(outstandingCall.event, 10000, FALSE) == WAIT_OBJECT_0;
outstandingCall.jsCallback(outstandingCall.jsContext);
```  

## <span data-ttu-id="3cffe-188">関連項目</span><span class="sxs-lookup"><span data-stu-id="3cffe-188">See also</span></span>  

*   [<span data-ttu-id="3cffe-189">JavaScript ランタイムサンプルアプリ</span><span class="sxs-lookup"><span data-stu-id="3cffe-189">JavaScript Runtime Sample App</span></span>](https://go.microsoft.com/fwlink/p/?LinkID=306674&clcid=0x409)   
*   [<span data-ttu-id="3cffe-190">リファレンス (JavaScript ランタイム)</span><span class="sxs-lookup"><span data-stu-id="3cffe-190">Reference (JavaScript Runtime)</span></span>](../chakra-hosting/reference-javascript-runtime.md)   
*   [<span data-ttu-id="3cffe-191">JavaScript ランタイムのホスティング</span><span class="sxs-lookup"><span data-stu-id="3cffe-191">JavaScript Runtime Hosting</span></span>](../javascript-runtime-hosting.md)  
